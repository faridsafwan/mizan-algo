{"version":3,"sources":["../src/OptionParser.js"],"names":["OptionParser","flags","string","stringOpt","option","type","args","push","boolOpt","set","find","flag","includes","isSet","length","rest","i","e","char1","substring","char2","split","slash","indexOf","equalSign","juxtapose","filterBool","filter","c","charAt","bool","index","checkType","toString","iterator"],"mappings":"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","sourcesContent":["import { _ } from \"lodash\";\n\n// [{\n//   'option' : 'I',\n//   'type'   : 'string',\n//   'args'   : [/lib1,/lib2,/lib3]\n// },\n// {\n//   'option' : 'h help',\n//   'type'   : 'boolean',\n//   'set'    : true\n// }]\n\n// Initializing a class definition\nexport default class OptionParser {\n  constructor() {\n    this.flags = [];\n  }\n\n  addStringOption(string) {\n    // TODO - add white space separated flag list (long and short flags)\n    const stringOpt = {\n      option: string,\n      type: \"string\",\n      args: [],\n    };\n    this.flags.push(stringOpt);\n  }\n\n  addBoolOption(string) {\n    // TODO - add white space separated flag list (long and short flags)\n    const boolOpt = {\n      option: string,\n      type: \"boolean\",\n      set: false,\n    };\n    this.flags.push(boolOpt);\n  }\n\n  isSet(string) {\n    // TODO - return true if a flag (bool or string) was set\n    let find = this.flags.find((flag) => flag.option.includes(string));\n    let isSet = false;\n    if (find && find.type === \"string\") {\n      if (find.args.length) {\n        isSet = true;\n      }\n    } else if (find && find.type === \"boolean\") {\n      isSet = find.set;\n    }\n    return isSet;\n  }\n\n  parse(args) {\n    // TODO - parse command line arguments\n\n    // Separation Criteria\n    // 1. - (option after -, arg after option) / (space)\n    // 2. -- (option after --, arg after =, eg.--filetype=txt)\n    // Extract option, add argument\n    let rest = [];\n    for (let i = 0; i < args.length; i++) {\n      const e = args[i];\n      if (!e) {\n        continue;\n      }\n      const char1 = e.substring(0, 1);\n      const char2 = e.substring(0, 2);\n      if (char2 === \"--\") {\n        const split = e.split(\"=\");\n        const option = split[0].substring(2);\n        let find = this.flags.find((e) => e.option.includes(option));\n        find.args.push(split[1]);\n      } else if (char1 === \"-\") {\n        const slash = e.indexOf(\"/\");\n        const equalSign = e.indexOf(\"=\");\n        if (slash === -1) {\n          // no slash\n          const option = e.substring(1);\n          let find = this.flags.find((flag) => flag.option.includes(option));\n          if (find && find.type === \"string\") {\n            find.args.push(args[i + 1]);\n            delete args[i + 1];\n          } else {\n            let juxtapose = true;\n            const filterBool = this.flags.filter((e) => e.type === \"boolean\");\n            // check for possibility to juxtapose\n            for (const c of option) {\n              let find = filterBool.find((flag) => flag.option.charAt(0) === c);\n              if (!find) {\n                juxtapose = false;\n              }\n            }\n            if (juxtapose === true) {\n              for (const bool of filterBool) {\n                bool.set = true;\n              }\n            } else {\n              if (find) {\n                find.set = true;\n              }\n            }\n          }\n        } else if (equalSign !== -1) {\n          // have equal sign\n          const split = e.split(\"=\");\n          const option = split[0].substring(1);\n          let find = this.flags.find((flag) => flag.option.includes(option));\n          find.args.push(split[1]);\n        } else {\n          const index = e.indexOf(\"/\");\n          const option = e.substring(1, index);\n          const args = e.substring(index);\n          // check available one char\n          const checkType = this.flags.find((flag) =>\n            flag.option.includes(option)\n          );\n          if (checkType.type === \"string\") {\n            checkType.args.push(args);\n          } else {\n            checkType.set = true;\n          }\n        }\n      } else {\n        rest.push(e);\n      }\n    }\n    return rest;\n  }\n\n  get(string) {\n    // TODO - return first string argument for flag\n    let find = this.flags.find((flag) => flag.option.includes(string));\n    return find.args.toString();\n  }\n\n  getAll(string) {\n    // TODO - return all string arguments for flag\n    let find = this.flags.find((flag) => flag.option.includes(string));\n    return find.args;\n  }\n\n  reset() {\n    // TODO  - unsets all flags\n    for (const iterator of this.flags) {\n      if (iterator.type === \"string\") {\n        iterator.args = [];\n      } else {\n        iterator.set = false;\n      }\n    }\n  }\n}\n"],"file":"OptionParser.js"}